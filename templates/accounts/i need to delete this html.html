<script>
        // Retrieve room slug and sender ID from the template context
        const roomSlug = '{{ room.slug }}';
    const senderId = '{{ user.id }}';
    const receiverId = '{{ receiver.id }}'; // Receiver's ID

    // Determine the correct WebSocket protocol
    const websocketProtocol = window.location.protocol === "https:" ? "wss" : "ws";

    // Update the WebSocket endpoint to use the room slug
    const wsEndpoint = `${websocketProtocol}://${window.location.host}/ws/chat/${roomSlug}/`;

    const socket = new WebSocket(wsEndpoint);

    socket.onopen = function () {
        console.log("WebSocket connection opened");
        console.log("Current User ID:", senderId);
    };

    socket.onmessage = function (event) {
        try {
            const data = JSON.parse(event.data);
            console.log("WebSocket message received:", data);

            // Handle user status updates
            if (data.status) {
                const userId = data.user_id;
                const status = data.status;

                if (userId !== senderId) {
                    // Update the receiver's status if it's the receiverId
                    if (userId == receiverId) {
                        const receiverStatusElement = document.getElementById('receiverStatus');
                        if (receiverStatusElement) {
                            receiverStatusElement.textContent = status === 'online' ? 'Online' : 'Offline';
                        }
                    }

                    // Update the status for other participants in the room
                    const participantStatusElement = document.getElementById(userId);
                    if (participantStatusElement) {
                        participantStatusElement.querySelector('.userStatus').textContent = status === 'online' ? 'Online' : 'Offline';
                    }
                }
            } else if (data.message) {
                // Handle incoming messages
                const message = data.message;
                const messageSenderId = data.sender_id;
                const senderProfilePic = data.sender_profile_pic;

                const messageElement = document.createElement('div');
                const isSender = messageSenderId == senderId;

                if (isSender) {
                    messageElement.className = 'senderMessage';
                    messageElement.innerHTML = `
                <p>${message}</p>
                <div class="receiverMessageImg">
                    <img src="${senderProfilePic}" alt="Profile Picture">
                </div>
            `;
                } else {
                    messageElement.className = 'receiverMessage';
                    messageElement.innerHTML = `
                <div class="receiverMessageImg">
                    <img src="${senderProfilePic}" alt="Profile Picture">
                </div>
                <p>${message}</p>
            `;
                }

                // Update unread message indicator for this room
                updateUnreadMessageIndicator(roomSlug);

                const chatContainer = document.getElementById('chatContainer');
                chatContainer.appendChild(messageElement);
                scrollToBottom();
            }
        } catch (error) {
            console.error("Error processing WebSocket message:", error);
        }
    };

    socket.onerror = function (error) {
        console.error("WebSocket error:", error);
    };

    socket.onclose = function () {
        console.log("WebSocket connection closed!");
    };

    function sendMessage() {
        const messageInput = document.getElementById('messageInput');
        const message = messageInput.value.trim();

        if (message) {
            socket.send(JSON.stringify({
                'message': message,
                'sender_id': senderId,
                'receiver_id': receiverId,
                'sender_profile_pic': '{{ user.userprofile.profile_picture.url }}'
            }));
            messageInput.value = '';
        }
    }

    document.getElementById('sendMessageButton').addEventListener('click', function (event) {
        event.preventDefault();
        sendMessage();
    });

    function scrollToBottom() {
        const chatContainer = document.getElementById('chatContainer');
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // Unread message notifications
    function updateUnreadMessageIndicator(roomSlug) {
        const roomElement = document.querySelector(`#room-${roomSlug}`);
        if (roomElement) {
            const notificationElement = roomElement.querySelector('.notification-icon');
            if (notificationElement) {
                // Show the green dot if there are unread messages
                notificationElement.style.display = 'block';
            } else {
                console.error("Notification element not found for room:", roomSlug);
            }
        } else {
            console.error("Room element not found for roomSlug:", roomSlug);
        }
    }

    function hideUnreadMessageIndicator(roomSlug) {
        const roomElement = document.querySelector(`#room-${roomSlug}`);
        if (roomElement) {
            const notificationElement = roomElement.querySelector('.notification-icon');
            if (notificationElement) {
                // Hide the green dot
                notificationElement.style.display = 'none';
            }
        }
    }

    function enterRoom() {
        socket.send(JSON.stringify({
            'command': 'mark_as_read',
            'room_slug': roomSlug
        }));

        // Hide the unread message indicator
        hideUnreadMessageIndicator(roomSlug);
    }

</script>
<script>
        document.addEventListener('DOMContentLoaded', () => {
        const roomSlug = '{{ room.slug }}';
        const senderId = '{{ user.id }}';
        const receiverId = '{{ receiver.id }}'; // Receiver's ID

        const websocketProtocol = window.location.protocol === "https:" ? "wss" : "ws";
        const wsEndpoint = `${websocketProtocol}://${window.location.host}/ws/chat/${roomSlug}/`;

        const socket = new WebSocket(wsEndpoint);

        socket.onopen = function () {
            console.log("WebSocket connection opened");
            console.log("Current User ID:", senderId);
        };

        socket.onmessage = function (event) {
            try {
                const data = JSON.parse(event.data);
                console.log("WebSocket message received:", data);

                if (data.hasOwnProperty('status')) {
                    handleUserStatus(data);
                } else if (data.hasOwnProperty('message')) {
                    handleMessage(data);
                }
            } catch (error) {
                console.error("Error processing WebSocket message:", error);
            }
        };

        socket.onerror = function (error) {
            console.error("WebSocket error:", error);
        };

        socket.onclose = function () {
            console.log("WebSocket connection closed!");
        };

        function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();

            if (message && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    'message': message,
                    'sender_id': senderId,
                    'receiver_id': receiverId,
                    'sender_profile_pic': '{{ user.userprofile.profile_picture.url }}'
                }));
                messageInput.value = '';
            } else {
                console.error("WebSocket is not open. Message not sent.");
            }
        }

        document.getElementById('sendMessageButton').addEventListener('click', function (event) {
            event.preventDefault();
            sendMessage();
        });

        function handleUserStatus(data) {
            const userId = data.user_id;
            const status = data.status;

            if (userId == receiverId) {
                const receiverStatusElement = document.getElementById('receiverStatus');
                if (receiverStatusElement) {
                    receiverStatusElement.textContent = status === 'online' ? 'Online' : 'Offline';
                }
            }

            const participantStatusElement = document.getElementById(userId);
            if (participantStatusElement) {
                participantStatusElement.querySelector('.userStatus').textContent = status === 'online' ? 'Online' : 'Offline';
            }

            const onlineUsers = document.querySelectorAll('.userStatus');
            const allOnline = Array.from(onlineUsers).every(statusElement => statusElement.textContent === 'Online');

            if (allOnline) {
                markMessagesAsRead();
            }
        }

        function handleMessage(data) {
            const message = data.message;
            const messageSenderId = data.sender_id;
            const senderProfilePic = data.sender_profile_pic;
            const isSender = messageSenderId == senderId;

            if (!isSender) {
                // If the message is from the other user, append it and update the unread message indicator
                appendMessage(message, senderProfilePic, isSender);

                // Show unread message notification for the sender
                updateUnreadMessageIndicator(roomSlug);
            } else {
                // If the message is from the current user (sender), just append it, no notification
                appendMessage(message, senderProfilePic, isSender);
            }

            scrollToBottom();
        }

        function appendMessage(message, senderProfilePic, isSender) {
            const messageElement = document.createElement('div');

            if (isSender) {
                messageElement.className = 'senderMessage';
                messageElement.innerHTML = `
                <p>${message}</p>
                <div class="receiverMessageImg">
                    <img src="${senderProfilePic}" alt="Profile Picture">
                </div>
            `;
            } else {
                messageElement.className = 'receiverMessage';
                messageElement.innerHTML = `
                <div class="receiverMessageImg">
                    <img src="${senderProfilePic}" alt="Profile Picture">
                </div>
                <p>${message}</p>
            `;
            }

            const chatContainer = document.getElementById('chatContainer');
            chatContainer.appendChild(messageElement);
        }

        function scrollToBottom() {
            const chatContainer = document.getElementById('chatContainer');
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function updateUnreadMessageIndicator(roomSlug) {
            const roomElement = document.querySelector(`#room-${roomSlug}`);
            if (roomElement) {
                const notificationElement = roomElement.querySelector('.notification-icon');
                if (notificationElement) {
                    notificationElement.style.display = 'block'; // Show the notification icon
                }
            }
        }

        function hideUnreadMessageIndicator(roomSlug) {
            const roomElement = document.querySelector(`#room-${roomSlug}`);
            if (roomElement) {
                const notificationElement = roomElement.querySelector('.notification-icon');
                if (notificationElement) {
                    notificationElement.style.display = 'none'; // Hide the notification icon
                }
            }
        }

        function markMessagesAsRead() {
            socket.send(JSON.stringify({
                'command': 'mark_as_read',
                'room_slug': roomSlug
            }));

            hideUnreadMessageIndicator(roomSlug);
        }

        function enterRoom() {
            socket.send(JSON.stringify({
                'command': 'mark_as_read',
                'room_slug': roomSlug
            }));

            hideUnreadMessageIndicator(roomSlug);
        }
    });

</script>